Dev-Ops: otomasyon

dockerfile yazma:
golang compile etçez localde compile ettiğimi dockerda etçem benim belirttiğim bi işletim sistemi içinde çalışan proje hale gelicek 

FROM golang:1.20.5-alpine 

RUN go version


dockerfile hazırladık ama image oluşmadı build almamız gerekiyomuş
docker build -t egitim-kampi-docker dedik docker huba login olmadığım için sorun çıktı düzelttik

docker build -t egitim-kampi-docker
docker run egitim-kampi-docker dedik 
docker ps
docker images | grep oluşturduğumuz_image


dockerfileda her değişiklik yaptığımızda tekrar build alıyoruz sonra runlıyoruz.

FROM golang:1.20.5-alpine 

CMD ["go", "version"]

---------------------------------------------------------------

FROM golang:1.20.5-alpine 

COPY . .

RUN go build main.go

CMD ["./main"]

en temel haliyle bu şekilde  

---------------------------------------------------------------

bu yazdığımız image ın boyutu çok büyük o yüzden bi takım düzenlemeler falan yaptık ve düştü

FROM golang:1.20.5-alpine AS builder

WORKDIR /app

COPY . .

RUN go build main.go

FROM alpine

COPY --from=builder /app /app

CMD ["/app/main"]


mantığıda ilk başta golang kurulu olan bi işletim sistemi kuruyoruz onun içerisinde build alıyoruz ve o build aldığımız binaryi golang olmayan bir Linux işletim sisteminde çalıştırıyoruz. 

scratch ile bunu daha da düşerebilirz alpine yerine scratch kullanarak

maine bir http func yazdık sonra 


jenkins için bir dosya ve dockerfile oluşturduk jenkinsi çalıştırınca benim dockera ihtiyacım olucak ama içersinde docker yok docker benim kendi makinamda dockerfile içinde 
get.docker la SL sini jenkins makinasına kurdum.

FROM jenkins/jenkins

USER root
RUN apt-get update \
      && apt-get install -y sudo
      && rm -rf /var/lib/apt/lists/*
RUN echo "jenkins ALL=NOPASSWD: ALL" >> /etc/sudoers
RUN curl /sSL https://get.docker.com | sh

localhostta jenkinse girdikten sonra new item diyorum multibranch pipeline seçelim

sonra script kısmına gelip hello worldü seçtik buraya stageler ekledi 
1-static code analysiz 
2-test
3-buid
4-deploy
çok basit bi pipeline yazdık aslında

pipeline {
    agent any

    stages {
        stage('Checkout') {      
            steps {
                checkout scm   
            }
        }
        
        stage('Static Code Analysiz') {
            steps {
                echo 'static analysis...'
            }
        }
        
        stage('Test') {
            steps {
                echo 'testler calisti'
            }
        }
        
        stage('Build') {
            steps {
                echo 'build...'

            }
        }
        
        stage('Deploy') {
            steps {
                echo 'deploying...'
            }
        }
    }
}

sonra bu daha önceki docker buildi jenkinsin içine alalım diyor gittik githubda repo açtık
sonra bi gitignore eksikti onu açtık docker buildin oraya sonra mainimizi dockerfileı falan
commit ettik 

jenkinsile pipeline oluşturmayı cı cıd falan bişeyler yaptık stageler oluşturdu pipeline faln

şimdide bir build alcak bu kadar bilgilerle git clone adresini aldı
jenkinse gidiyor configure e geliyor github projete urli yapıştırıyor 
poll scm i tikliiyor buda repoma yeni commit geldiğinde build alıyo:
* * * * * her dakikada bir build almasını sağlamak için bunu yazdı.


pipeline script kısmına gelip yeni stage ekledi :

stages {
    stage('Checkout') {
  	steps{
	    checkout scm
     }
  }
}


sonra bu scripti kodumuzu repo ya Jenkinsfile olarak ekledi

git add ler ile

hata aldığında jenkins makinasına bağlanıp şu aşağıdakileri yapmış
docker start 392
docker exec -it 392 /bin/sh
git config --global https.sslVerify false

sonra bizim yazdığımız checkout adımına gerek yokmuş dedi

sonra pipeline kodumuzdaki build stagenin stepini 
        sh 'docker build -t first-build' 
olarak değiştirdi. 
bunu gite pushladı

daha detayli gerçekçi bir pipeline yazmayı bize bıraktı.(öğren)

şimdi artık bu api yi deploy edelim çalıştıralım artık her şey hazır

bunu nerde çalıştırcaz kubernetes dedi
dockerın içinde bir kubernetesi çalışıyomuş öyle dedi
argocd kurucakmış buraya onunla uı dan bi kaç konfigürasyonla deploymant filelarımızı kuberneteste çalıştırıcaz uyg nın çalıştığını göstercek maksat argocd

https://x.com/mstryoda_/status/1362056930886361092


ArgoCD ile Kubernetes cluster'ıne deployment yapalım.

kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

2.adım projemiz için deployment oluştujrcaz gerçekten dockerhubdan çekilebilcek bi proje olsun diyo onun manifestlerini oluşturalım

k create deployment nginx --iamge=nginx -n default --dry-run=client -o yaml 
bu bizim deployment manifestimizmiş	(k yada kubectl)

sanırım altına deployment.yaml yazdı tam göremedim orayı)ha bunu deployment.yaml adında bi dosya şeklinde git repo dosyamızın içine atmış

kuberneteste uygulamayı çalıştırmak istediğimizde çeşitli resourcelar var deployment diye bişi var içinde containerları alıyo mesela nginx bunu deploy etçez.

network için erişilebilir olması için service diye bi objede var onuda oluşturmamız lazımmış:
k expose deployment nginx --port 80 --target-port 80 --dry-run=client -o yaml

deployments.app "nginx" not found hatası aldı bunu yazdı:
k create deployment nginx --iamge=nginx -n default
sonra bunu k delete deployment -n default nginx yazıp sildi

sonra oluşturduğu bu deployment.yaml ve service.yaml i deployment adında bir dosya oluşturup içine attı ve repoya pushladı












Kubernetes bileşenleri
Aşağıda bazı kubernetes bileşenleri ve karşılıkları yer almaktadır.

Pod – Container/Uygulamalar yer alır.
Deployment – Pod oluşturma tanımları yer alır.
Service – Pod erişim bilgileri yer alır.
Ingress – Uygulama/Pod trafiğini yönlendirir.
ConfigMap – Uygulamaya ait ayarlar yer alır.
Secrets – Uygulamaya ait bilgiler base64 formatında yer alır.
Volumes – Uygulamaya ait kalıcı veri tanımları yer alır.
StatefulSet – Verilerin kalıcı olduğu uygulamalarda kullanılır.
NOT: pod ifadesi container ifadesine karşılık gelmektedir.
















